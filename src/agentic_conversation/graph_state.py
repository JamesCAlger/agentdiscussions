"""
LangGraph state definitions and transition functions for conversation orchestration.

This module defines the state structure used by LangGraph to manage conversation
flow between agents, including state transitions and termination conditions.
"""

from typing import TypedDict, Optional, List, Dict, Any, Callable
from enum import Enum
from dataclasses import dataclass

from .models import ConversationState, ConversationStatus


class ControlAction(Enum):
    """Enumeration of control actions for conversation flow."""
    CONTINUE = "continue"
    SWITCH_AGENT = "switch_agent"
    TERMINATE_SUCCESS = "terminate_success"
    TERMINATE_ERROR = "terminate_error"
    TERMINATE_MAX_TURNS = "terminate_max_turns"
    TERMINATE_TIMEOUT = "terminate_timeout"


class GraphState(TypedDict):
    """
    State structure for LangGraph conversation orchestration.
    
    This TypedDict defines the complete state that flows through the LangGraph
    state machine during conversation execution.
    
    Attributes:
        conversation_state: The current conversation state with messages and metadata
        current_agent: ID of the agent that should respond next ("agent_a" or "agent_b")
        should_continue: Boolean flag indicating if conversation should continue
        control_action: The next control action to take in the conversation flow
        error_message: Optional error message if an error occurred
        last_response: The last response generated by an agent
        turn_start_time: Timestamp when the current turn started
        metadata: Additional metadata for the current state
    """
    conversation_state: ConversationState
    current_agent: str
    should_continue: bool
    control_action: ControlAction
    error_message: Optional[str]
    last_response: Optional[str]
    turn_start_time: Optional[float]
    metadata: Dict[str, Any]


@dataclass
class StateTransitionResult:
    """
    Result of a state transition operation.
    
    Attributes:
        new_state: The updated graph state after transition
        action_taken: Description of the action that was taken
        should_continue: Whether the conversation should continue
        termination_reason: Reason for termination if conversation should stop
    """
    new_state: GraphState
    action_taken: str
    should_continue: bool
    termination_reason: Optional[str] = None


class StateTransitionManager:
    """
    Manages state transitions and termination conditions for conversation flow.
    
    This class contains the logic for determining when to switch agents,
    when to terminate conversations, and how to handle error states.
    """
    
    def __init__(self, max_turns: int = 20, turn_timeout: float = 30.0):
        """
        Initialize the state transition manager.
        
        Args:
            max_turns: Maximum number of turns before termination
            turn_timeout: Maximum time per turn in seconds
        """
        self.max_turns = max_turns
        self.turn_timeout = turn_timeout
    
    def should_terminate_max_turns(self, state: GraphState) -> bool:
        """
        Check if conversation should terminate due to maximum turns reached.
        
        Args:
            state: Current graph state
            
        Returns:
            True if max turns reached, False otherwise
        """
        return state["conversation_state"].current_turn >= self.max_turns
    
    def should_terminate_error(self, state: GraphState) -> bool:
        """
        Check if conversation should terminate due to error state.
        
        Args:
            state: Current graph state
            
        Returns:
            True if in error state, False otherwise
        """
        return (
            state["error_message"] is not None or
            state["conversation_state"].status == ConversationStatus.ERROR
        )
    
    def should_terminate_timeout(self, state: GraphState, current_time: float) -> bool:
        """
        Check if conversation should terminate due to turn timeout.
        
        Args:
            state: Current graph state
            current_time: Current timestamp
            
        Returns:
            True if turn has timed out, False otherwise
        """
        if state["turn_start_time"] is None:
            return False
        
        elapsed_time = current_time - state["turn_start_time"]
        return elapsed_time > self.turn_timeout
    
    def get_next_agent(self, current_agent: str) -> str:
        """
        Get the ID of the next agent to respond.
        
        Args:
            current_agent: ID of the current agent
            
        Returns:
            ID of the next agent ("agent_a" or "agent_b")
        """
        return "agent_b" if current_agent == "agent_a" else "agent_a"
    
    def determine_control_action(self, state: GraphState, current_time: float) -> ControlAction:
        """
        Determine the next control action based on current state.
        
        Args:
            state: Current graph state
            current_time: Current timestamp
            
        Returns:
            The control action that should be taken next
        """
        # Check termination conditions first
        if self.should_terminate_error(state):
            return ControlAction.TERMINATE_ERROR
        
        if self.should_terminate_timeout(state, current_time):
            return ControlAction.TERMINATE_TIMEOUT
        
        if self.should_terminate_max_turns(state):
            return ControlAction.TERMINATE_MAX_TURNS
        
        # Check if conversation is marked as completed
        if state["conversation_state"].status == ConversationStatus.COMPLETED:
            return ControlAction.TERMINATE_SUCCESS
        
        # Continue conversation by switching to next agent
        return ControlAction.SWITCH_AGENT
    
    def transition_to_next_agent(self, state: GraphState) -> StateTransitionResult:
        """
        Transition state to the next agent's turn.
        
        Args:
            state: Current graph state
            
        Returns:
            StateTransitionResult with updated state
        """
        next_agent = self.get_next_agent(state["current_agent"])
        
        new_state = state.copy()
        new_state["current_agent"] = next_agent
        new_state["control_action"] = ControlAction.CONTINUE
        new_state["should_continue"] = True
        new_state["turn_start_time"] = None  # Will be set when turn actually starts
        
        return StateTransitionResult(
            new_state=new_state,
            action_taken=f"Switched to {next_agent}",
            should_continue=True
        )
    
    def transition_to_termination(
        self, 
        state: GraphState, 
        control_action: ControlAction,
        reason: str
    ) -> StateTransitionResult:
        """
        Transition state to termination.
        
        Args:
            state: Current graph state
            control_action: The termination control action
            reason: Reason for termination
            
        Returns:
            StateTransitionResult with terminated state
        """
        new_state = state.copy()
        new_state["should_continue"] = False
        new_state["control_action"] = control_action
        
        # Update conversation status based on termination reason
        if control_action == ControlAction.TERMINATE_SUCCESS:
            new_state["conversation_state"].status = ConversationStatus.COMPLETED
        elif control_action == ControlAction.TERMINATE_ERROR:
            new_state["conversation_state"].status = ConversationStatus.ERROR
        else:
            new_state["conversation_state"].status = ConversationStatus.TERMINATED
        
        return StateTransitionResult(
            new_state=new_state,
            action_taken=f"Terminated conversation: {reason}",
            should_continue=False,
            termination_reason=reason
        )
    
    def execute_state_transition(self, state: GraphState, current_time: float) -> StateTransitionResult:
        """
        Execute a state transition based on current state and conditions.
        
        Args:
            state: Current graph state
            current_time: Current timestamp
            
        Returns:
            StateTransitionResult with the new state and action taken
        """
        control_action = self.determine_control_action(state, current_time)
        
        if control_action == ControlAction.SWITCH_AGENT:
            return self.transition_to_next_agent(state)
        elif control_action == ControlAction.TERMINATE_SUCCESS:
            return self.transition_to_termination(
                state, control_action, "Conversation completed successfully"
            )
        elif control_action == ControlAction.TERMINATE_ERROR:
            error_msg = state.get("error_message", "Unknown error occurred")
            return self.transition_to_termination(
                state, control_action, f"Error: {error_msg}"
            )
        elif control_action == ControlAction.TERMINATE_TIMEOUT:
            return self.transition_to_termination(
                state, control_action, f"Turn timeout exceeded ({self.turn_timeout}s)"
            )
        elif control_action == ControlAction.TERMINATE_MAX_TURNS:
            return self.transition_to_termination(
                state, control_action, f"Maximum turns reached ({self.max_turns})"
            )
        else:
            # Default to continuing
            new_state = state.copy()
            new_state["control_action"] = ControlAction.CONTINUE
            new_state["should_continue"] = True
            
            return StateTransitionResult(
                new_state=new_state,
                action_taken="Continue current state",
                should_continue=True
            )


def create_initial_graph_state(
    conversation_state: ConversationState,
    starting_agent: str = "agent_a"
) -> GraphState:
    """
    Create an initial graph state for a new conversation.
    
    Args:
        conversation_state: Initial conversation state
        starting_agent: ID of the agent to start the conversation
        
    Returns:
        Initial GraphState ready for LangGraph execution
    """
    return GraphState(
        conversation_state=conversation_state,
        current_agent=starting_agent,
        should_continue=True,
        control_action=ControlAction.CONTINUE,
        error_message=None,
        last_response=None,
        turn_start_time=None,
        metadata={}
    )


def update_state_with_response(
    state: GraphState,
    response: str,
    agent_id: str,
    response_time: float,
    token_count: int
) -> GraphState:
    """
    Update graph state with a new agent response.
    
    Args:
        state: Current graph state
        response: The agent's response text
        agent_id: ID of the responding agent
        response_time: Time taken to generate the response
        token_count: Number of tokens in the response
        
    Returns:
        Updated GraphState with the new response
    """
    from datetime import datetime
    from .models import Message
    
    # Create new message
    message = Message(
        agent_id=agent_id,
        content=response,
        timestamp=datetime.now(),
        token_count=token_count,
        metadata={"response_time": response_time}
    )
    
    # Update conversation state
    new_conversation_state = state["conversation_state"]
    new_conversation_state.add_message(message)
    
    # Update graph state
    new_state = state.copy()
    new_state["conversation_state"] = new_conversation_state
    new_state["last_response"] = response
    new_state["metadata"]["last_response_time"] = response_time
    new_state["metadata"]["last_token_count"] = token_count
    
    return new_state


def update_state_with_error(
    state: GraphState,
    error_message: str,
    agent_id: Optional[str] = None
) -> GraphState:
    """
    Update graph state with an error condition.
    
    Args:
        state: Current graph state
        error_message: Description of the error
        agent_id: ID of the agent that encountered the error (optional)
        
    Returns:
        Updated GraphState with error information
    """
    new_state = state.copy()
    new_state["error_message"] = error_message
    new_state["conversation_state"].status = ConversationStatus.ERROR
    new_state["control_action"] = ControlAction.TERMINATE_ERROR
    new_state["should_continue"] = False
    
    if agent_id:
        new_state["metadata"]["error_agent"] = agent_id
    
    return new_state


# Type aliases for state transition functions
StateTransitionFunction = Callable[[GraphState], StateTransitionResult]
StateUpdateFunction = Callable[[GraphState, Dict[str, Any]], GraphState]